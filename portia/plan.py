"""Plan primitives and data models for Portia.

This module defines foundational data structures used throughout Portia:

- `Variable`: A reference to an output from a previous step or plan input.
- `PlanInput`: An input variable for a plan, with optional description and value.
- `Step`: A data model for UI serialization representing a step in the dashboard.
- `ReadOnlyStep`: A read-only version of a `Step` used for passing steps to agents.
- `PlanContext`: Provides context about the plan, including the original query and available tools.

Note: The main Plan class and PlanBuilder are now located in the builder module.
Use `from portia.builder import Plan, PlanBuilder` to build and execute plans.

"""

from __future__ import annotations

from pydantic import BaseModel, ConfigDict, Field, field_serializer

from portia.common import Serializable
from portia.prefixed_uuid import PlanUUID


class Variable(BaseModel):
    """A reference to an output of a step.

    Args:
        name (str): The name of the output or plan input to reference, e.g. $best_offers.
        description (str): A description of the output or plan input.

    """

    model_config = ConfigDict(extra="ignore")

    name: str = Field(
        description="The name of the output or plan input to reference, e.g. $best_offers. "
        "This must reference an existing output or plan input. IMPORTANT: Do not use this field to "
        "pass values to a step as the execution agent will manage that.",
    )
    description: str = Field(
        description="A description of the output or plan input.",
        default="",
    )

    def pretty_print(self) -> str:
        """Return the pretty print representation of the variable.

        Returns:
            str: A pretty print representation of the variable's name, and description.

        """
        return f"{self.name}: ({self.description})"


class PlanInput(BaseModel):
    """An input to a plan.

    Args:
        name (str): The name of the input, e.g. $api_key.
        description (str): A description of the input.

    """

    model_config = ConfigDict(extra="ignore")

    name: str = Field(
        description="The name of the input",
    )
    description: str | None = Field(
        description="A description of the input. This is used during planning to help the planning "
        "agent understand how to use the input.",
        default=None,
    )
    value: Serializable | None = Field(
        description=(
            "The value of the input. This is only used when running a plan and isn't used during "
            "planning."
        ),
        default=None,
    )

    def pretty_print(self) -> str:
        """Return the pretty print representation of the plan input.

        Returns:
            str: A pretty print representation of the input's name, and description.

        """
        return f"{self.name}: ({self.description or 'No description'})"


class Step(BaseModel):
    """A step data model used for UI serialization.

    This class is a data structure used to represent steps in the Portia UI/dashboard.
    It is generated by the new Plan class (formerly PlanV2) via the to_step_data() method
    on step objects.

    Args:
        task (str): The task that needs to be completed by this step.
        inputs (list[Variable]): The input to the step, as a reference to an output of a previous
          step or a plan input
        tool_id (str | None): The ID of the tool used in this step, if applicable.
        output (str): The unique output ID for the result of this step.

    """

    model_config = ConfigDict(extra="allow")

    task: str = Field(
        description="The task that needs to be completed by this step",
    )
    inputs: list[Variable] = Field(
        default=[],
        description=(
            "Inputs to the step that reference an output of a previous step or a plan input."
            "They should not be used to pass values to steps, only to reference previous outputs."
        ),
    )
    tool_id: str | None = Field(
        default=None,
        description="The ID of the tool listed in <Tools/>",
    )
    output: str = Field(
        ...,
        description="The unique output id of this step e.g. $best_offers.",
    )
    condition: str | None = Field(
        default=None,
        description="A human readable condition which controls if the step is run or not. "
        "If provided the condition will be evaluated and the step skipped if false. "
        "The step will run by default if not provided.",
    )
    structured_output_schema: type[BaseModel] | None = Field(
        default=None,
        exclude=True,
        description="The optional structured output schema for output of this step.",
    )

    def pretty_print(self) -> str:
        """Return the pretty print representation of the step.

        Returns:
            str: A pretty print representation of the step's task, inputs, tool_id, and output.

        """
        message = (
            f"- {self.task}\n"
            f"    Inputs: {', '.join([var.pretty_print() for var in self.inputs])}\n"
            f"    Tool ID: {self.tool_id}\n"
            f"    Output: {self.output}\n"
        )
        if self.condition:
            message += f"  Condition: {self.condition}\n"
        return message


class ReadOnlyStep(Step):
    """A read-only copy of a step, passed to agents for reference.

    This class creates an immutable representation of a step, which is used to ensure agents
    do not modify the original plan during execution.

    Args:
        step (Step): A step object from which to create a read-only version.

    """

    model_config = ConfigDict(frozen=True, extra="forbid")

    @classmethod
    def from_step(cls, step: Step) -> ReadOnlyStep:
        """Create a read-only step from a normal step.

        Args:
            step (Step): The step to be converted to read-only.

        Returns:
            ReadOnlyStep: A new read-only step.

        """
        return cls(
            task=step.task,
            inputs=step.inputs,
            tool_id=step.tool_id,
            output=step.output,
            condition=step.condition,
            structured_output_schema=step.structured_output_schema,
        )


class PlanContext(BaseModel):
    """Context for a plan.

    The plan context contains information about the original query and the tools available
    for the planning agent to use when generating the plan.

    Args:
        query (str): The original query given by the user.
        tool_ids (list[str]): A list of tool IDs available to the planning agent.

    """

    model_config = ConfigDict(extra="forbid")

    query: str = Field(description="The original query given by the user.")
    tool_ids: list[str] = Field(
        description="The list of tools IDs available to the planning agent.",
    )

    @field_serializer("tool_ids")
    def serialize_tool_ids(self, tool_ids: list[str]) -> list[str]:
        """Serialize the tool_ids to a sorted list.

        Returns:
            list[str]: The tool_ids as a sorted list.

        """
        return sorted(tool_ids)


# Legacy Plan class for backward compatibility with ToolRunContext
# This will be removed in a future version
class LegacyPlan(BaseModel):
    """Legacy plan structure for backward compatibility.

    This class exists temporarily to support ToolRunContext during the migration.
    It will be removed in a future version.
    """

    model_config = ConfigDict(extra="forbid")

    id: PlanUUID = Field(
        default_factory=PlanUUID,
        description="The ID of the plan.",
    )
    plan_context: PlanContext = Field(description="The context for when the plan was created.")
    steps: list[Step] = Field(description="The set of steps to solve the query.")
    plan_inputs: list[PlanInput] = Field(
        default=[],
        description="The inputs required by the plan.",
    )
    structured_output_schema: type[BaseModel] | None = Field(
        default=None,
        exclude=True,
        description="The optional structured output schema for the query.",
    )
